/** \file msgcli.c \author Filippo Fontanelli mat 422385 Si dichiara che il contenuto di questo file e' in ogni sua parte opera originale dell' autore.  */#include "msgcli.h"/*#define DEBUG*/pthread_t *tid_sender, *tid_receiver, *tid_csignal;int fd_skt, termina = 0;sigset_t * set_h, *set_m,*set;pthread_mutex_t mtx_termina = PTHREAD_MUTEX_INITIALIZER;/** Controlla che l'input ricevuto rispetti i parametri richiesti*/static char checkinput(char * input);/** Un gestore di segnali che non fa nulla*/static void gestore(int signum) {	return;}int main(int argc, char *argv[]) {	int connectionok = 0;	struct sigaction s;	message_t *domanda, *risposta;	mtrace();	/*Controllo la variabile argc per verificare che il numero di parametri */	if (argc != 2) {#ifdef DEBUG		printf("ERROR : msgcli : (argc != s), argc = %d.\n",argc);#endif		fprintf(stderr, ERRARGC);		free_all(1);	}#ifdef DEBUG	printf("OK : msgser : client %s attivo.\n", argv[1]);#endif	/*maschero i segnali SIGINT SIGTERM SIGPIPE e gestisco SIGUSR1*/	set = malloc(sizeof(sigset_t));	sigemptyset(set);	sigaddset(set, SIGINT);	sigaddset(set, SIGTERM);	bzero(&s,sizeof(s));	s.sa_handler = SIG_IGN;	sigaction(SIGPIPE,&s,NULL);	s.sa_handler = &gestore;	sigaction(SIGUSR1,&s,NULL);	pthread_sigmask(SIG_SETMASK, set, NULL);	/*Tento di aprire una connessione per 5 volte con una pausa di 1 secondo*/	do {		if (connectionok > 0) sleep(1);		fd_skt = openConnection("./tmp/msgsock");		connectionok++;		if (fd_skt == SNAMETOOLONG) {			fprintf(stderr,					"Impossible Aprire una connessione, lenght(path) is true long.End all\n");		}		if (fd_skt == -1) {			fprintf(stderr,					"Impossible Aprire una connessione a msgsock, error (-1). N %d\n",connectionok);		}	}while (fd_skt < 0 && connectionok < 5);	if (fd_skt < 0) {#ifdef DEBUG		fprintf(stderr,"Numero di tentativi di connessioni eccessivo!!\n");#endif		free_all(1);	}#ifdef DEBUG	printf("OK : msgcli : Connessione su ./tmp/msgsoc aperta con fd_skt = %d.\n",fd_skt);#endif	/*preparo le strutture dati di tipo message_t utilizzate successivamente*/	risposta = calloc(sizeof(message_t), 1);	domanda = calloc(sizeof(message_t), 1);	risposta->buffer = NULL;	risposta->length = 0;	domanda->buffer = NULL;	domanda->length = 0;	/*Start connessione con il server*/	termina = c_control_send_message(domanda, argv[1], MSG_CONNECT, fd_skt, "ERROR : msgcli : Errorre nella spedizione del messaggio : Connessione MSG_CONNECT.\n");	if (termina == 1) {		free_all(1);	}	free(domanda);	termina = c_control_recive_message(risposta, fd_skt, "ERROR : msgcli : Errorre nella ricezione del messaggio: MSG_CONNECTION_OK??.\n)");	if (termina == 1) {		free_all(1);	}	/*End connessione con il server*/	switch (risposta->type) {		case MSG_ERROR: {#ifdef DEBUG			fprintf(stderr, "Messaggio di errore ricevuto dal server :%s\n",risposta->buffer);#endif			free_all(1);			break;		}		case MSG_OK: {			if (risposta->buffer != NULL) free(risposta->buffer);				free(risposta);			tid_sender = malloc(sizeof(pthread_t));			tid_receiver = malloc(sizeof(pthread_t));			tid_csignal = malloc(sizeof(pthread_t));			pthread_create(tid_sender, NULL, &sender, NULL);			pthread_create(tid_receiver, NULL, &receiver , NULL);			pthread_create(tid_csignal, NULL, &handler_signal, NULL);			if (tid_sender == NULL || tid_receiver == NULL ) {				termina = 1;				break;			}			/*mi pongo in attesa della terminazione di tutti i thread*/			pthread_join(*tid_csignal,NULL);			pthread_join(*tid_sender, NULL);			pthread_join(*tid_receiver, NULL);		}	}	free_all(0);	if (risposta->buffer != NULL) {			free(risposta->buffer);		}	free(risposta);	return 0;}void *receiver() {	short check = 0;	message_t *risposta;	risposta = calloc(sizeof(message_t), 1);	risposta->buffer = NULL;	risposta->length = 0;#ifdef DEBUG	printf("OK : receiver() : START\n");#endif	do {		check = c_control_recive_message(risposta, fd_skt, "ERROR : RECIVER : msgcli : Errorre nella ricezione del messaggio.\n");		if (!check) {			switch (risposta->type) {				case MSG_TO_ONE:				printf("%s\n",risposta->buffer);				fflush(stdout);				break;				case MSG_LIST:				printf("[LIST] %s\n",risposta->buffer);				fflush(stdout);				break;				case MSG_BCAST:				printf("[BCAST]%s\n",risposta->buffer);				fflush(stdout);				break;				case MSG_ERROR:				printf("[ERROR] %s\n",risposta->buffer);				fflush(stdout);				break;				case MSG_NO:				check=1;				break;				default:				printf("Messaggio inaspettato Type :%c , Buffer :%s\n",risposta->type, risposta->buffer);				check = 1;				break;			}		}	}while (!check);	free(risposta);	if (closeSocket(fd_skt) == -1) fprintf(stderr,"ERROR : WORKER : MSG_EXIT :  nella chiusra del socket dopo un MSG_EXIT\n");	pthread_mutex_lock(&mtx_termina);	if (!termina) {		termina = 1;		pthread_mutex_unlock(&mtx_termina);		if (pthread_kill(*tid_sender, SIGUSR1) != 0)		fprintf(stderr, "errore kill thread handler\n");		if (pthread_kill(*tid_csignal, SIGINT) != 0)		fprintf(stderr, "errore kill thread handler\n");	}	pthread_mutex_unlock(&mtx_termina);#ifdef DEBUG	printf("OK : receiver() : END\n");#endif	return 0;}void *sender() {	short check = 0;	char typemessage;	char *user_input;	message_t *domanda;	domanda = calloc(sizeof(message_t), 1);	domanda->buffer = NULL;	domanda->length = 0;	user_input = calloc(sizeof(char), BUFSIZ);#ifdef DEBUG	printf("OK : sender() : START\n");#endif	do {		user_input = fgets(user_input, BUFSIZ, stdin);		if (user_input == NULL) {			c_control_send_message(domanda, NULL, MSG_EXIT, fd_skt, "ERROR : SENDER : msgcli : Errorre nella lettura da input : temrino thread.\n");			check = 1;		} else {			if ((typemessage = checkinput(user_input)) != 'F') {				/*Pongo '\0' alla fine della stringa di input dell'utente*/				user_input[strlen(user_input)-1] = '\0';				switch (typemessage) {					case MSG_EXIT:					c_control_send_message(domanda, NULL, MSG_EXIT, fd_skt, "ERROR : SENDER : msgcli : Errorre nella spedizione del messaggio  : MSG_EXIT.\n");					check = 1;					break;					case MSG_LIST:					c_control_send_message(domanda, NULL, MSG_LIST, fd_skt, "ERROR : SENDER : msgcli : Errorre nella spedizione del messaggio  : MSG_LIST.\n");					break;					case MSG_BCAST:					c_control_send_message(domanda, user_input, MSG_BCAST, fd_skt, "ERROR : SENDER : msgcli : Errorre nella spedizione del messaggio  : MSG_BCAST .\n");					break;					case MSG_TO_ONE:					c_control_send_message(domanda, user_input, MSG_TO_ONE, fd_skt, "ERROR : SENDER : msgcli : Errorre nella spedizione del messaggio  : MSG_TO_ONE.\n");					break;				}			} else {				printf("Messaggio ripilogativo di tutti i comandi....\n");				fflush(stdout);			}		}	}while (!check);	free(user_input);	free(domanda);	pthread_join(*tid_receiver, NULL);	pthread_mutex_lock(&mtx_termina);	if (!termina) {		termina = 1;		pthread_mutex_unlock(&mtx_termina);		if (pthread_kill(*tid_csignal, SIGINT) != 0)		fprintf(stderr, "errore kill thread handler\n");		if (pthread_kill(*tid_receiver, SIGUSR1) != 0)		fprintf(stderr, "errore kill thread handler\n");	}	pthread_mutex_unlock(&mtx_termina);#ifdef DEBUG	printf("OK : sender() : END\n");#endif	return 0;}void *handler_signal() {	int signum = 0;	set_h = malloc(sizeof(sigset_t));	sigemptyset(set_h);	sigaddset(set_h, SIGINT);	sigaddset(set_h, SIGTERM);	sigwait(set_h, &signum);	if (!termina) {		free_all(0);		termina = 1;		if (pthread_kill(*tid_sender, SIGUSR1) != 0) {			fprintf(stderr, "errore kill thread handler\n");		}		if (pthread_kill(*tid_receiver, SIGUSR1) != 0) {			fprintf(stderr, "errore kill thread handler\n");		}	}	return NULL;}void free_all(int valueexit) {	free(tid_sender);	free(tid_receiver);	free(tid_csignal);	free(set);	free(set_h);	free(set_m);	exit(valueexit);}static char checkinput(char * input) {	if (input == NULL)	return 'F';	if (strlen(input) <= 0)	return 'F';	if ((*input != '%') && (*input != ' ') && (strlen(input) > 0))	return MSG_BCAST;	if (strncmp(input + 1, "LIST", 4) == 0)	return MSG_LIST;	if (strncmp(input + 1, "EXIT", 4) == 0)	return MSG_EXIT;	if (strncmp(input + 1, "ONE", 3) == 0) {		char s[BUFSIZE];		if (sscanf(input, "%%ONE %s %s", s, s) != 2) {			fprintf(stderr,ERRFORM);			return 'F';		}		return MSG_TO_ONE;	}#ifdef DEBUG	printf(ERRFORM);#endif	return 'F';}