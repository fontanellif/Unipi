/** \file msgserv.c \author Filippo Fontanelli mat 422385 Si dichiara che il contenuto di questo file e' in ogni sua parte opera originale dell' autore.  */#include "msgserv.h"/*#define DEBUG*/static pthread_cond_t cond_queue = PTHREAD_COND_INITIALIZER;static pthread_mutex_t mtx_queue = PTHREAD_MUTEX_INITIALIZER;static pthread_mutex_t mtx_worker = PTHREAD_MUTEX_INITIALIZER;static pthread_mutex_t mtx_autor = PTHREAD_MUTEX_INITIALIZER;static hashTable_t *hashaut;/*tabella hash destinata a contenere le informazioni degli utenti autorizzati*/static hashTable_t *allworker;/*tabella hash destinata a contenere le informazioni sui socket attivi*/FILE *flog;/*file contenente il log dei messaggi inviati con successo al server*/int *main_tid;/*tid del main*/int sockets;/*socket su cui e' connesso il server*/static queue *coda;/*struttura dati condivisa*/volatile sig_atomic_t termina_sign = 0;/*segnali, variabile di terminazione*/pthread_t *tid_writer, *tid_worker, *tid_handler;/*tid dei thread del processo*//*Gestore di segnali vuoto*/static void gestore(int signum) {	return;}void *handler() {	int signum = 0;	sigset_t * pset = malloc(sizeof(sigset_t));	sigemptyset(pset);	sigaddset(pset, SIGINT);	sigaddset(pset, SIGTERM);	sigwait(pset, &signum);	termina_sign = 1;	system("rm ./tmp/msgsock");	if (pthread_kill(*main_tid, SIGUSR1) != 0)	fprintf(stderr, "errore kill thread main\n");	if (pthread_kill(*tid_writer, SIGUSR1) != 0)	fprintf(stderr, "errore kill thread main\n");	fprintf(stderr, "ERROR : msgserv : Terminazione forzata da SIGINT o SIGTERM.\n");	termina_workers(&mtx_worker);	closeSocket(sockets);	free(pset);	return NULL;}int main(int argc, char *argv[]) {	int socketc;/*socket del client*/	sigset_t *set;/*seganli*/	FILE *faut;/*file degli utenti autorizzati*/	struct sigaction s;/*seganli*/		main_tid = (int*)pthread_self();	/*	 * maschero i segnali SIGINT SIGTERM SIGPIPE	 */	set = malloc(sizeof(sigset_t));	sigemptyset(set);	sigaddset(set, SIGINT);	sigaddset(set, SIGTERM);	sigaddset(set, SIGPIPE);	pthread_sigmask(SIG_SETMASK, set, NULL);	bzero(&s,sizeof(s));	s.sa_handler = &gestore;	sigaction(SIGUSR1,&s,NULL);		if(preparing_data_structures(argc, argv,&hashaut,&faut, &flog, mtx_autor))	return 1;	if(creating_main_structures(&sockets, &allworker,&coda,&tid_writer,&tid_worker,&tid_handler,&handler,&writer)) {		pthread_mutex_lock(&mtx_autor);		if (hashaut != NULL)		free_hashTable(&hashaut);		free(hashaut);		pthread_mutex_unlock(&mtx_autor);		return 1;	}#ifdef DEBUG	printf("OK : msgserv : Server in ascolto sulla socket : %d\n",sockets);	fflush(stdout);#endif	while (!termina_sign) {#ifdef DEBUG		printf("OK : msgserv : IN ATTESA DI RICHIESTE DI CONNESSIONE\n");		fflush(stdout);#endif		if(AcceptConnection(&socketc, sockets, &tid_worker, &workers,termina_sign)) {			closeSocket(sockets);			free(coda);			pthread_mutex_lock(&mtx_autor);			if (hashaut != NULL)			free_hashTable(&hashaut);			free(hashaut);			pthread_mutex_unlock(&mtx_autor);			pthread_mutex_lock(&mtx_worker);			if (allworker != NULL)			free_hashTable(&allworker);			free(allworker);			pthread_mutex_unlock(&mtx_worker);			free(tid_handler);			free(tid_writer);			/*End free*/			return 1;		}	}	pthread_join(*tid_handler, NULL);	/*	 * Termino tutti i worker, effettuando secondo la mia logica una ricerca nella tabella hash dove l'ho salvati	 */	if (!termina_sign) {		termina_workers(&mtx_worker);		closeSocket(sockets);		system("rm ./tmp/msgsock");		free(set);	}	/*	 * Adesso procedo ad elimiare la memoria allocata	 */	/*start free*/	free(coda);	fclose(flog);	pthread_mutex_lock(&mtx_autor);	if (hashaut != NULL)	free_hashTable(&hashaut);	free(hashaut);	pthread_mutex_unlock(&mtx_autor);	pthread_mutex_lock(&mtx_worker);	if (allworker != NULL)	free_hashTable(&allworker);	free(allworker);	pthread_mutex_unlock(&mtx_worker);	free(tid_handler);	free(tid_writer);	/*End free*/	return 0;}/* * il writer e' un processo che viene attivato immediatamente dal server, il quale rimane in eseguzione per tutto il ciclio di vita di esso, *  prelevando i messaggi dalla coda dei messaggi e li scrive nel file di log */void *writer() {	do {		char *currentmessage = calloc(sizeof(char),BUFSIZE);		currentmessage = dequeue(coda,&mtx_queue,&cond_queue);		if (currentmessage == NULL) {			fprintf(stderr,"ERROR : WRITER : msgserv : currentmessage = dequeue(coda).\n");		} else {			fprintf(flog, "%s\n", currentmessage);			fflush(flog);		}		free(currentmessage);	}while (!termina_sign);#ifdef DEBUG	printf("OK : msgser : writer :exit \n");	fflush(stdout);#endif	return 0;}/* * wokrer, funzione passata ai thread attivati dal server, ha come parametro la socket precendentemente aperta */void *workers(void *socket) {	int userduplicate = 0 , *fd_skt , termina = 0;	message_t *domanda, *risposta;/*strutture dati per i messaggi*/	pthread_t *mytid;/*my tid*/	elem_t * client_aut;/*elemento della tabella hash, utilizzato per i controlli su essa*/	char *client;/*stringa utilizzata per memorizzare il client mittente del messaggio*/	char * msglog;/*stringa utilizzata per contenere il testo da salvare nel file di log*/	char *mess_bcast;	int socketw;/*utilizzata per memoriazzare il socket ricevuto come parametro*/	socketw =(int)(socket);	/*Determino il tid del worker attuale*/	mytid = malloc(sizeof(pthread_t));	*mytid = pthread_self();	/*Alloco le strutture dati per i messaggi di domanda e risposta*/	risposta = malloc(sizeof(message_t));	domanda = malloc(sizeof(message_t));	do {		risposta->buffer = NULL;		risposta->length = 0;		domanda->buffer = NULL;		domanda->length = 0;		if(!(termina = s_control_recive_message(domanda, socketw))) {			switch (domanda->type) {#ifdef DEBUG				printf("---%c\n",domanda->type);				fflush(stdout);#endif				case MSG_CONNECT: {					msg_connect(domanda, &risposta, socketw, &termina, &userduplicate,client_aut, &client,mytid,&allworker,hashaut,mtx_autor,mtx_worker);					break;				}case MSG_LIST: {					msg_list(&risposta,socketw, &termina,hashaut, mtx_autor);				}break;				case MSG_EXIT: {					msg_exit(&risposta,socketw, &termina,client_aut, client,hashaut, mtx_autor);					break;				}case MSG_TO_ONE: {					msg_to_one(domanda, &risposta, socketw,							client, &termina,hashaut,mtx_autor, coda,  mtx_queue,cond_queue);					break;				}case MSG_BCAST: {					int i;					mess_bcast = calloc(sizeof(char), (domanda->length + strlen(client)+LENGTHEADER+1));					if (mess_bcast == NULL)					termina = 1;					else {						strcat(mess_bcast, "[");						strcat(mess_bcast, client);						strcat(mess_bcast, "] ");						if(domanda->buffer != NULL)						strcat(mess_bcast, domanda->buffer);						mess_bcast[strlen(mess_bcast)] = '\0';						pthread_mutex_lock(&mtx_autor);						for (i = 0; i < hashaut->size; i++) {							elem_t *e;							if (hashaut->table[i] != NULL) {								e = hashaut->table[i]->head;								while (e != NULL) {									fd_skt = e->payload;									if (*fd_skt > 0) {										termina = s_control_send_message(risposta,mess_bcast, MSG_BCAST, *fd_skt);										if (!termina) {											msglog = logtoqueue(client, (char *) e->key, domanda->buffer);											enqueue(msglog, coda,&mtx_queue,&cond_queue);										}									}									e = e->next;								}							}						}						pthread_mutex_unlock(&mtx_autor);						free(mess_bcast);					}					break;				}default: {					fprintf(stderr,"ERROR : WORKER : msgserv : switch(type), tipo : %c inaspettato.\n",domanda->type);					termina = 1;					break;}			}		}	}while(domanda->type != MSG_EXIT && !termina && !termina_sign);	if (!userduplicate) {		pthread_mutex_lock(&mtx_autor);		client_aut = point_find_hashElement(hashaut, client);		pthread_mutex_unlock(&mtx_autor);		if (client_aut != NULL)		*((int*) (client_aut->payload)) = -1;		pthread_mutex_lock(&mtx_worker);		remove_hashElement(allworker, client);		pthread_mutex_unlock(&mtx_worker);	}	free(risposta);	if (domanda->buffer != NULL)	free(domanda->buffer);	free(domanda);	free(mytid);#ifdef DEBUG	printf("OK : msgser : worker :exit \n");	fflush(stdout);#endif	return 0;}void termina_workers(pthread_mutex_t *mtx_worker) {	/*Termino tutti i worker, effettuando secondo la mia logica una ricerca nella tabella hash dove l'ho salvati*/	list_t **l;	list_t *t;	elem_t *e;	int i;	pthread_mutex_lock(mtx_worker);	l = allworker->table;	for ( i = 0; i < allworker->size; i++) {		t = l[i];		if (t != NULL) {			e = t->head;			while (e != NULL) {				if (pthread_kill(*(pthread_t*) (e->payload), SIGUSR1) != 0) {					perror("Kill error thread");					fprintf(stderr,"ERROR : msgserv : UTILITYSERVER: pthread_kill .\n");				}				e = e->next;			}		}	}	pthread_mutex_unlock(mtx_worker);}