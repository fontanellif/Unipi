/** \file queue.c \author Filippo Fontanelli mat 422385 Si dichiara che il contenuto di questo file e' in ogni sua parte opera originale dell' autore.  */#include "queue.h"int initialize(queue *q){	if (q != NULL) {		q->cnt = EMPTY;		q->front = NULL;		q->rear = NULL;	}else 		return 1;		return 0;}void enqueue(char *m,queue *q,pthread_mutex_t *mtx,pthread_cond_t * cond){	elem_q *p;	pthread_mutex_lock(mtx);	p= malloc(sizeof(elem_q));	p->message = m;	p->next = NULL;	if (!empty(q)) {		q->rear->next = p;		q->rear = p;	}else 		q->front = q->rear = p;	q->cnt++;	pthread_cond_signal(cond);	pthread_mutex_unlock(mtx);}char* dequeue(queue *q,pthread_mutex_t *mtx,pthread_cond_t * cond){	char *m;	elem_q	*p;	pthread_mutex_lock(mtx);	while (empty(q)){		pthread_cond_wait(cond, mtx);	}	m = q->front->message;	p = q->front;	q->front = q->front->next;	q->cnt--;		free(p);	pthread_mutex_unlock(mtx);	return m;	}char* front(const queue *q,pthread_mutex_t *mtx){	char * tmp;	pthread_mutex_lock(mtx);	tmp = q->front->message;	pthread_mutex_unlock(mtx);	return tmp;}/* *Metodo che viene chiamato solamente all'interno delle due funzioni principali, *le quali gestiscono la mutex */int empty(const queue *q){	return (q->cnt == EMPTY);}	int full(const queue *q,pthread_mutex_t *mtx){	int tmp;	pthread_mutex_lock(mtx);	tmp = (q->cnt == FULL);	pthread_mutex_unlock(mtx);	return tmp;}